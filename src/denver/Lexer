import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.StringTokenizer;


public class Main {
    public static void main(String[] args) {
        try {
            long[] dog = {1,2,3,4};

            ArrayList<String> datatypes = new ArrayList<>();
            datatypes.add("int");
            datatypes.add("float");
            datatypes.add("double");
            datatypes.add("long");
            datatypes.add("char");
            datatypes.add("String");
            datatypes.add("char");
            datatypes.add("boolean");

            ArrayList<Character> numbers = new ArrayList<Character>();
            numbers.add('0');
            numbers.add('1');
            numbers.add('2');

            HashMap<String, String> keywords = new HashMap<>();
            keywords.put("for","for loop");

            ArrayList<String> keyword = new ArrayList<>();
            keyword.add("class");
            keyword.add("public");
            keyword.add("main");

            ArrayList<String> symbols = new ArrayList<>();
            symbols.add("(");
            symbols.add(")");
            symbols.add("{");
            symbols.add("}");

            ArrayList<String> arithmaticOperators = new ArrayList<>();
            arithmaticOperators.add("+");
            arithmaticOperators.add("-");
            arithmaticOperators.add("*");
            arithmaticOperators.add("/");
            arithmaticOperators.add("%");
            arithmaticOperators.add("++");
            arithmaticOperators.add("--");
            arithmaticOperators.add("+");
            arithmaticOperators.add("+");

            ArrayList<String> assignmentOperators = new ArrayList<>();
            assignmentOperators.add("=");
            assignmentOperators.add("+=");
            assignmentOperators.add("-=");
            assignmentOperators.add("/=");
            assignmentOperators.add("%=");
            assignmentOperators.add("&=");
            assignmentOperators.add("|=");
            assignmentOperators.add("^=");
            assignmentOperators.add(">>=");
            assignmentOperators.add("<<=");

            ArrayList<String> modifiers = new ArrayList<>();
            modifiers.add("static");
            modifiers.add("final");
            modifiers.add("abstract");
            modifiers.add("transient");
            modifiers.add("synchronized");
            modifiers.add("volatile");

            ArrayList<String> accessModifiers = new ArrayList<>();
            accessModifiers.add("public");
            accessModifiers.add("private");
            accessModifiers.add("default");
            accessModifiers.add("protected");

            ArrayList<String> returnType = new ArrayList<>();
            returnType.add("void");

            ArrayList<String> comparisonOperators = new ArrayList<>();
            comparisonOperators.add("==");
            comparisonOperators.add("!=");
            comparisonOperators.add(">");
            comparisonOperators.add("<");
            comparisonOperators.add(">=");
            comparisonOperators.add("<=");

            ArrayList<String> logicalOperators = new ArrayList<>();
            logicalOperators.add("&&");
            logicalOperators.add("||");
            logicalOperators.add("!");


            LinkedList<String> script = new LinkedList<>(); // Linked list containing basic tokes
            LinkedList<String> headers = new LinkedList<>(); // Linked List containing tokens from lines with headers
            LinkedList<String> containsBrackets = new LinkedList<>(); // Linked List containing tokens from lines with brackets
            LinkedList<String> forLoop = new LinkedList<>(); // Linked List containing tokens from lines with for loops
            LinkedList<String> systOut = new LinkedList<>(); // Linked List for Print statements



            File file = new File("Code"); // File containing source code
            BufferedReader br = new BufferedReader(new FileReader(file)); // Buffered Reader to read in source file code


            String linee; // Varibale representing lines of code read in from source code txt file
            String token; // Variable representing individual tokesn
            String header;

            // Counters unique to each Linked List

            int i = 0; // Base counter variable for Linked List containing tokens from lines
                       // without brackets, headers, or comments
            int j = 0; // Counter variable for headers Linked List
            int z = 0; // Counter variable for brackets Linked List
            int u = 0; // Counter variable for for loop Linked List
            int v = 0;
            int l = 1; // Counter variable for line number

            // Loop that facilitates the lexical analysis of a source code read in from a file

            while ((linee = br.readLine())!= null) {
                System.out.println("Line " + l + ": " + linee);

                // Lexical breakdown of lines of code containing "Headers"

                if (linee.contains("public class") || linee.contains("public static void main")) {
                    StringTokenizer hdr = new StringTokenizer(linee);
                    while (hdr.hasMoreTokens()) {
                        String wrd = hdr.nextToken();
                        headers.add(wrd);
                    }

                    while (j < headers.size()) {
                        if (accessModifiers.contains(header = headers.get(j))) {
                            System.out.println(header + " --> Access Modifier");
                        }
                        else if (modifiers.contains(header = headers.get(j))){
                            System.out.println(header + " --> Modifier");
                        }
                        else if (returnType.contains(header = headers.get(j))){
                            System.out.println(header + " --> Return Type");
                        }
                        else if (keyword.contains(header = headers.get(j))){
                            System.out.println(header + " --> Keyword");
                        }
                        else if (keyword.contains(header = headers.get(j-1))){
                            header = headers.get(j);
                            System.out.println(header + " --> Class Name (IDENTIFIER)");
                        }
                        j++;
                    }


                }

                // Lexical breakdown of lines of code containing brackets

                else if (linee.contains("[]") || linee.contains("[") || linee.contains("]")){
                    String arrayDeclaration = linee;
                    StringBuilder separate = new StringBuilder();
                    StringTokenizer brac = new StringTokenizer(linee);
                    for (int k = 1; k < arrayDeclaration.length(); k++) {
                        char c = arrayDeclaration.charAt(k-1);
                        char c1 = arrayDeclaration.charAt(k);
                        if (c == '[' && c1 == ']'){
                            System.out.println("[] --> LBracket and RBracket");
                        }
                    }
                    while (brac.hasMoreTokens()) {
                        String dec = brac.nextToken(); // Declaration
                        containsBrackets.add(dec);
                    }
                    while (z < containsBrackets.size()) {
                        if (datatypes.contains(token = containsBrackets.get(z))) {
                            System.out.println(token + " --> DataType");
                            System.out.println(token = containsBrackets.get(z + 1) + " --> IDENTIFIER Represents Variable Name");
                        }
                        else if (assignmentOperators.contains(token = containsBrackets.get(z))) {
                            System.out.println(token + " --> Assignment Operator");
                            if (containsBrackets.get(z + 1).equals("new")) {
                                System.out.println(token = containsBrackets.get(z + 1) + " --> Keyword for Array Initialization");

                            }
                            //System.out.println(token = containsBrackets.get(z + 1) + " --> Value");
                        }
                        else if(containsBrackets.get(z).contains("[")){
                            token = containsBrackets.get(z);
                            if (token.length() == 3){
                                System.out.println(containsBrackets.get(z-1)+ "--> IDENTIFIER Represents Varibale Name");
                                System.out.println(token +"--> Initializing index");
                            }
                        }
                        /*else if (containsBrackets.get(z).contains("[") && (containsBrackets.get(z).length() == 3)){
                            System.out.println(containsBrackets.get(z) +" --> Variable name(IDENTIFIER)");
                        }*/
                        else {
                            if (containsBrackets.get(z) != "new") {
                            }


                        }
                        z++;
                    }

                }
                else if(linee.contains("//")){
                    System.out.println(linee + " --> Comment");
                }

                // Lexical breakdown of lines of code containing for loops

                else if(linee.contains("for")){
                    StringTokenizer forr = new StringTokenizer(linee);
                    while (forr.hasMoreTokens()) {
                        String loopVar = forr.nextToken(); // Declaration
                        forLoop.add(loopVar);
                    }
                    while (u < forLoop.size()) {
                        if (datatypes.contains(token = forLoop.get(u))) {
                            System.out.println(token + " --> DataType");
                            System.out.println(token = forLoop.get(u + 1) + " --> IDENTIFIER Represents Variable Name");
                        }
                        else if (assignmentOperators.contains(token = forLoop.get(u))) {
                            System.out.println(token + " --> Assignment Operator");
                            System.out.println(token = forLoop.get(u + 1) + " --> Value");
                        }
                        else if (symbols.contains(token = forLoop.get(u))){
                            if (token.equals("(") || token.equals(")")){
                                System.out.println(token + " --> Parentheses");
                            }
                            else {
                                System.out.println(token + " --> Curly Brackets");
                            }

                        }
                        else if(comparisonOperators.contains(token = forLoop.get(u))) {
                            System.out.println(token + " --> Comparison Operator");

                        }
                        else if(forLoop.get(u).contains("++")){
                            System.out.println(forLoop.get(u) + " --> Increment Operator");
                        }
                        else if(keywords.containsKey(token = forLoop.get(u))){
                            System.out.println(token + " --> Keyword for a " + keywords.get(token));
                        }
                        u++;

                        }



                }

                else if(linee.contains("System.out.print")){
                    StringTokenizer out = new StringTokenizer(linee);
                    while (out.hasMoreTokens()) {
                        String outt = out.nextToken();
                        systOut.add(outt);
                    }
                    while (v < systOut.size()){
                        if (systOut.get(v).contains("[")){
                            System.out.println(systOut.get(v-1) + " --> IDENTIFIER Variable Name");
                            System.out.println(systOut.get(v) + " --> Index Location");

                        }
                        else if (systOut.get(v).contains("System")){
                            System.out.println(systOut.get(v) + " --> Print Statement");
                        }
                    }
                }
                else {
                    StringTokenizer str = new StringTokenizer(linee);
                    while (str.hasMoreTokens()) {
                        String word = str.nextToken();
                        script.add(word);
                    }
                    while (i < script.size()) {
                        if (datatypes.contains(token = script.get(i))) {
                            System.out.println(token + " --> DataType");
                            System.out.println(token = script.get(i + 1) + " --> IDENTIFIER Represents Variable Name");
                        }
                        else if (assignmentOperators.contains(token = script.get(i))) {
                            System.out.println(token + " --> Assignment Operator");
                            System.out.println(token = script.get(i + 1) + " --> Value");
                        }
                        else if (symbols.contains(token = script.get(i))){
                            if (token.equals("(") || token.equals(")")){
                                System.out.println(token + " --> Parentheses");
                            }
                            else {
                                System.out.println(token + " --> Curly Brackets");
                            }
                        }
                        i++;
                    }
                }
                l++;
            }

        } catch(FileNotFoundException e){

        } catch (IOException e) {
            throw new RuntimeException(e);
        }


    }
